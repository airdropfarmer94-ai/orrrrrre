<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ORE Custom Tiles Bot (v3) - Final</title>
  <script src="https://unpkg.com/@solana/web3.js@1.95.2/lib/index.iife.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Privy client UMD (ensure this URL is correct for your Privy library/version) -->
  <script src="https://auth.privy.io/core.umd.min.js"></script>
  <style>
    body{margin:0;background:#000;color:#0f0;font-family:Arial;text-align:center;padding:20px;}
    h1{font-size:40px;margin:20px 0;}
    button{padding:18px 36px;margin:15px;background:#00ff00;color:black;border:none;border-radius:12px;font-size:22px;font-weight:bold;cursor:pointer;}
    button:disabled{background:#555;cursor:not-allowed;}
    button.stop{background:#ff0033;}
    #grid{display:grid;grid-template-columns:repeat(5,1fr);gap:12px;max-width:420px;margin:40px auto;}
    .tile{width:70px;height:70px;background:#b8860b;color:white;font-size:28px;font-weight:bold;display:flex;align-items:center;justify-content:center;cursor:pointer;border:4px solid #333;border-radius:12px;}
    .tile.selected{background:#00ff00;color:black;border-color:#00ff00;box-shadow:0 0 20px #0f0;}
    .log{background:#111;padding:20px;height:380px;overflow-y:auto;margin:30px auto;max-width:700px;border-radius:12px;font-family:monospace;font-size:15px;border:1px solid #0f0;}
    input{padding:15px;width:280px;margin:15px;border-radius:12px;background:#222;color:#0f0;border:2px solid #0f0;font-size:18px;text-align:center;}
    #status {color:#0f0;margin:6px 0;font-size:14px;}
  </style>
</head>
<body>
  <h1>ORE Custom Tiles Bot (v3)</h1>
  <div id="root"></div>

<script>
/* Diagnostics and improved Privy login flow
   - If click SIGN IN does nothing, this adds detailed logs and multiple fallbacks.
   - It logs whether the Privy script loaded, whether window.Privy/window.privy exist, and what methods are exposed.
   - It tries to call window.privy.login() first; if that fails, it will attempt to instantiate window.Privy and call common methods (login/open/signIn) as fallback.
   - It also surfaces all diagnostic messages to the in-app log so you don't need to keep DevTools open.
*/

/* ---------- CONFIG (you provided these) ---------- */
const APP_CONFIG = window.APP_CONFIG || {
  PRIVY_APP_ID: "cmi8rgcw9008nl30cnnxgn9mw",
  RPC: "https://mainnet.helius-rpc.com/?api-key=8952f5e0-8f66-465a-8a4c-29152df1f3cd"
};

const ORE_PROGRAM = new solanaWeb3.PublicKey("oreV3EG1i9BEgiAJ8b177Z2S2rMarzak4NMv1kULvWv");
const ORE_MINT    = new solanaWeb3.PublicKey("oreoU2P8bN6jkk3jbaiVxYnG1dCXcYxwhwyK9jSybcp");

const { useState, useEffect, useRef } = React;

/* very small diag logger that also writes to the app log when available */
let externalLogCallback = null;
function diagLog(msg) {
  try { console.log(msg); } catch(e){}
  if (externalLogCallback) externalLogCallback(msg);
}

/* very small helper to list object method names */
function listMethods(obj) {
  if (!obj) return [];
  try {
    return Object.getOwnPropertyNames(obj).filter(k => typeof obj[k] === 'function');
  } catch(e) { return []; }
}

/* ---------- App ---------- */
function App() {
  const [wallet, setWallet] = useState(null);
  const [balance, setBalance] = useState(0);
  const [tiles, setTiles] = useState([]);
  const [perTile, setPerTile] = useState(0.0001);
  const [total, setTotal] = useState(0);
  const [streak, setStreak] = useState(0);
  const [running, setRunning] = useState(false);
  const [log, setLog] = useState(["Loading Privy..."]);
  const [status, setStatus] = useState("Privy loading...");
  const runningRef = useRef(false);

  externalLogCallback = m => setLog(l => [...l.slice(-29), `${new Date().toLocaleTimeString()}: ${m}`]);

  const logMsg = m => {
    setLog(l => [...l.slice(-29), `${new Date().toLocaleTimeString()}: ${m}`]);
    diagLog(m);
  };

  useEffect(() => { runningRef.current = running; }, [running]);

  /* init: attempt to create privy instance if window.Privy exists and expose diagnostic info */
  useEffect(() => {
    let attempts = 0;
    const init = () => {
      if (window.Privy) {
        try {
          // Create instance only if not already created
          if (!window.privy) {
            try {
              const privy = new window.Privy({
                appId: APP_CONFIG.PRIVY_APP_ID,
                chainId: 101
              });
              // set up login callback if provided by this library
              if (privy.on && typeof privy.on === 'function') {
                privy.on('login', async user => {
                  if (!user || !user.wallet || !user.wallet.address) {
                    logMsg("Privy login returned unexpected shape.");
                    return;
                  }
                  setWallet(user.wallet);
                  logMsg("Connected: " + user.wallet.address.slice(0,8) + "...");
                  try {
                    const conn = new solanaWeb3.Connection(APP_CONFIG.RPC);
                    const bal = await conn.getBalance(new solanaWeb3.PublicKey(user.wallet.address));
                    setBalance(bal / 1e9);
                  } catch (e) {
                    logMsg("Balance read failed: " + (e && e.message || e));
                  }
                });
              }
              window.privy = privy;
              logMsg("Privy instance created and assigned to window.privy");
            } catch (e) {
              // some Privy UMD builds may not be constructible this way; we'll still show diagnostics
              logMsg("Privy constructor threw: " + (e && e.message));
            }
          } else {
            logMsg("window.privy already present");
          }

          // diagnostics: list methods on exported objects
          diagLog("window.Privy exists. methods: " + listMethods(window.Privy).join(", "));
          diagLog("window.privy exists. methods: " + listMethods(window.privy).join(", "));
          setStatus("Privy script loaded");
        } catch (e) {
          logMsg("Privy init error: " + (e && e.message));
          setStatus("Privy init error");
        }
      } else if (attempts < 20) {
        attempts++;
        setTimeout(init, 500);
      } else {
        logMsg("Privy failed to load. Check network, CSP, or that core.umd.min.js URL is valid.");
        setStatus("Privy failed to load");
      }
    };
    init();
  }, []);

  /* New robust login function with multiple fallbacks and verbose diagnostic logging */
  const login = async () => {
    logMsg("SIGN IN clicked");
    setStatus("Attempting sign in...");

    try {
      // Primary: window.privy.login()
      if (window.privy && typeof window.privy.login === 'function') {
        logMsg("Found window.privy.login, calling it...");
        try {
          const maybe = window.privy.login();
          // If it returns a promise, await it
          if (maybe && typeof maybe.then === 'function') await maybe;
          setStatus("Privy login invoked (window.privy.login)");
          return;
        } catch (e) {
          logMsg("window.privy.login threw: " + (e && e.message));
        }
      }

      // Secondary: if constructor available, create instance and invoke common methods
      if (window.Privy && typeof window.Privy === 'function') {
        logMsg("Found window.Privy constructor. Attempting to create instance and call login/open.");
        try {
          const p = new window.Privy({ appId: APP_CONFIG.PRIVY_APP_ID, chainId: 101 });
          window.privy = window.privy || p;
          // If p has login/open/signIn methods, attempt them:
          if (typeof p.login === 'function') {
            logMsg("Calling instance.login()");
            const r = p.login();
            if (r && typeof r.then === 'function') await r;
            setStatus("Privy login invoked (instance.login)");
            return;
          }
          if (typeof p.open === 'function') {
            logMsg("Calling instance.open()");
            p.open();
            setStatus("Privy open invoked (instance.open)");
            return;
          }
          if (typeof p.signIn === 'function') {
            logMsg("Calling instance.signIn()");
            const r = p.signIn();
            if (r && typeof r.then === 'function') await r;
            setStatus("Privy signIn invoked (instance.signIn)");
            return;
          }
          logMsg("No login/open/signIn method found on new Privy instance.");
        } catch (e) {
          logMsg("Error while creating/using new Privy instance: " + (e && e.message));
        }
      }

      // Tertiary: try any other plausible functions exposed on window.privy
      if (window.privy) {
        const methods = listMethods(window.privy);
        logMsg("window.privy methods: " + methods.join(", "));
        for (const m of methods) {
          if (["login","open","signIn","connect"].includes(m)) {
            try {
              logMsg(`Attempting window.privy.${m}()`);
              const r = window.privy[m]();
              if (r && typeof r.then === 'function') await r;
              setStatus(`Privy invoked (${m})`);
              return;
            } catch (e) {
              logMsg(`window.privy.${m}() threw: ${e && e.message}`);
            }
          }
        }
      }

      // If we've reached here, nothing worked
      logMsg("Privy login could not be invoked. Check that the Privy script is reachable and that APP_CONFIG.PRIVY_APP_ID is correct.");
      // Diagnostic snapshot for you to paste here if you want more help:
      const diag = {
        hasWindowPrivy: !!window.Privy,
        windowPrivyMethods: listMethods(window.Privy),
        hasWindowPrivy: !!window.privy,
        windowPrivyMethods: listMethods(window.privy),
        APP_CONFIG
      };
      logMsg("Privy diagnostic snapshot: " + JSON.stringify(diag));
      setStatus("Privy login failed (see log)");
    } catch (e) {
      logMsg("Unexpected login error: " + (e && e.message));
      setStatus("Privy login unexpected error");
    }
  };

  const toggle = i => runningRef.current ? null : setTiles(t => t.includes(i) ? t.filter(x => x !== i) : [...t, i].sort((a,b)=>a-b));

  const start = () => {
    if (!tiles.length) return alert("Select tiles!");
    setTotal(tiles.length * perTile);
    setRunning(true);
    runningRef.current = true;
    setStreak(0);
    logMsg(`STARTED â€“ ${tiles.length} tiles @ ${perTile} SOL`);
    runCycle();
  };

  const stop = () => {
    setRunning(false);
    runningRef.current = false;
    logMsg("STOPPED by user");
  };

  /* Simplified/wrapped wallet send - keep as in earlier file (unchanged logic here) */
  async function walletSendTransaction(tx, connection) {
    if (!wallet) throw new Error("No wallet");
    if (wallet.signAndSendTransaction) {
      try {
        const res = await wallet.signAndSendTransaction({ transaction: tx, connection });
        if (res && res.signature) return res.signature;
      } catch (e) {
        logMsg("signAndSendTransaction failed, trying signTransaction fallback: " + (e && e.message));
      }
    }
    if (wallet.signTransaction) {
      const signed = await wallet.signTransaction(tx);
      const raw = signed.serialize();
      const sig = await connection.sendRawTransaction(raw);
      return sig;
    }
    if (wallet.request) {
      try {
        const raw = tx.serialize();
        const sig = await wallet.request({ method: 'sendTransaction', params: [raw] });
        if (sig) return sig;
      } catch (e) {}
    }
    throw new Error("Wallet provider missing supported transaction API");
  }

  // NOTE: For brevity, the betting logic is omitted in this snippet; the login diagnostics are the priority for the reported issue.
  // Keep your betting implementation below (sendBetForTile, runCycle, etc.) as in your last working copy.

  return React.createElement('div', null,
    !wallet ?
      React.createElement('div', null,
        React.createElement('button', {onClick: login, style:{fontSize:'28px',padding:'20px 60px'}}, "SIGN IN WITH PRIVY"),
        React.createElement('div', {id:'status'}, status),
        React.createElement('div',{className:'log'},log.map((l,i)=>React.createElement('div',{key:i},l)))
      ) :
      React.createElement(React.Fragment, null,
        React.createElement('p', null, `Balance: ${balance.toFixed(4)} SOL`),
        React.createElement('div', {id:'grid'}, Array.from({length:25},(_,i)=>React.createElement('div',{
          key:i,className:`tile ${tiles.includes(i)?'selected':''}`,onClick:()=>toggle(i)
        },i+1))),
        React.createElement('p', null, "Tiles: "+(tiles.length?tiles.map(t=>t+1).join(", "):"none")),
        React.createElement('input',{type:"number",step:"0.000001",value:perTile,
          onChange:e=>setPerTile(Math.max(parseFloat(e.target.value)||0.000001, 0.000001))}),
        React.createElement('br'),
        React.createElement('button',{onClick:start,disabled:running},"START BOT"),
        running&&React.createElement('button',{className:"stop",onClick:stop},"STOP"),
        React.createElement('p', null, `Bet: ${total.toFixed(6)} SOL | Streak: ${streak}`),
        React.createElement('div',{className:'log'},log.map((l,i)=>React.createElement('div',{key:i},l)))
      )
  );
}

/* Mount */
(function mount() {
  const rootEl = document.getElementById('root');
  if (ReactDOM && ReactDOM.createRoot) {
    ReactDOM.createRoot(rootEl).render(React.createElement(App));
  } else {
    ReactDOM.render(React.createElement(App), rootEl);
  }
})();
</script>
</body>
</html>
