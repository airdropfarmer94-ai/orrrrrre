<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ORE Custom Tiles Bot (v3) - Final</title>
  <script src="https://unpkg.com/@solana/web3.js@1.95.2/lib/index.iife.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Privy client UMD (ensure this URL is correct for your Privy library/version) -->
  <script src="https://auth.privy.io/core.umd.min.js"></script>
  <style>
    body{margin:0;background:#000;color:#0f0;font-family:Arial;text-align:center;padding:20px;}
    h1{font-size:40px;margin:20px 0;}
    button{padding:18px 36px;margin:15px;background:#00ff00;color:black;border:none;border-radius:12px;font-size:22px;font-weight:bold;cursor:pointer;}
    button:disabled{background:#555;cursor:not-allowed;}
    button.stop{background:#ff0033;}
    #grid{display:grid;grid-template-columns:repeat(5,1fr);gap:12px;max-width:420px;margin:40px auto;}
    .tile{width:70px;height:70px;background:#b8860b;color:white;font-size:28px;font-weight:bold;display:flex;align-items:center;justify-content:center;cursor:pointer;border:4px solid #333;border-radius:12px;}
    .tile.selected{background:#00ff00;color:black;border-color:#00ff00;box-shadow:0 0 20px #0f0;}
    .log{background:#111;padding:20px;height:380px;overflow-y:auto;margin:30px auto;max-width:700px;border-radius:12px;font-family:monospace;font-size:15px;border:1px solid #0f0;}
    input{padding:15px;width:280px;margin:15px;border-radius:12px;background:#222;color:#0f0;border:2px solid #0f0;font-size:18px;text-align:center;}
  </style>
</head>
<body>
  <h1>ORE Custom Tiles Bot (v3)</h1>
  <div id="root"></div>

<script>
/*
  Finalized index.html

  Changes implemented:
  - APP_CONFIG filled with the PRIVY_APP_ID and HeliUS RPC you provided.
  - Instruction account template is derived at runtime from the supplied sample transaction (so the app can infer the exact accounts used in the real ORE program instruction).
  - Instruction data is serialized with explicit little-endian u64.
  - One transaction per tile.
  - Robust wallet send wrapper for provider differences.
  - React 18 createRoot usage.
  - Diagnostics for resource/fetch errors.

  IMPORTANT SECURITY NOTE:
  You provided secrets (PRIVY_APP_ID and Helius API key). These are included here because you asked to implement them; ideally you should inject them from a secure server-side environment (e.g., window.APP_CONFIG set by your server) or store them in Vercel secrets and inject at runtime. If this repo is public, consider rotating the Helius API key and the Privy app id after testing.
*/

/* ---------- CONFIG: Using values you provided ---------- */
const APP_CONFIG = window.APP_CONFIG || {
  PRIVY_APP_ID: "cmi8rgcw9008nl30cnnxgn9mw",
  RPC: "https://mainnet.helius-rpc.com/?api-key=8952f5e0-8f66-465a-8a4c-29152df1f3cd"
};

/* Sample transaction signature you provided — used to derive the account layout for the ORE instruction */
const SAMPLE_TX_SIG = "5wEnfmxKwYetnmqXsP6wMouar9HQJdqd8NgwcU6kDMp643cEKg52qda3LKnTsyWpLNFARZZKM1Gad6N2W7de6gc2";

/* Program & mint public keys (verify these are correct) */
const ORE_PROGRAM = new solanaWeb3.PublicKey("oreV3EG1i9BEgiAJ8b177Z2S2rMarzak4NMv1kULvWv");
const ORE_MINT    = new solanaWeb3.PublicKey("oreoU2P8bN6jkk3jbaiVxYnG1dCXcYxwhwyK9jSybcp");

/* ---------- Helpers ---------- */
const { useState, useEffect, useRef } = React;

function diagLog(msg) {
  try { console.log(msg); } catch (e) {}
}

/* Diagnostics for resource & fetch errors */
window.addEventListener('error', function (event) {
  if (event.target && (event.target.src || event.target.href)) {
    const url = event.target.src || event.target.href;
    diagLog(`Resource error: ${url} (tag: ${event.target.tagName})`);
  } else {
    diagLog(`Runtime error: ${event.message} at ${event.filename}:${event.lineno}:${event.colno}`);
  }
}, true);

window.addEventListener('unhandledrejection', function (evt) {
  const reason = evt.reason && (evt.reason.message || JSON.stringify(evt.reason)) || String(evt.reason);
  diagLog(`Unhandled Rejection: ${reason}`);
});

(function() {
  const nativeFetch = window.fetch;
  window.fetch = async function(...args) {
    try {
      const res = await nativeFetch.apply(this, args);
      if (!res.ok) diagLog(`Fetch failed: ${args[0]} -> ${res.status} ${res.statusText}`);
      return res;
    } catch (err) {
      diagLog(`Fetch error: ${args[0]} -> ${err && err.message ? err.message : err}`);
      throw err;
    }
  };
})();

/* Write little-endian u64 */
function writeU64LEInto(uint8arr, offset, value) {
  let v = BigInt(value);
  for (let i = 0; i < 8; i++) {
    uint8arr[offset + i] = Number((v >> BigInt(8 * i)) & BigInt(0xff));
  }
}

function buildInstructionData(discriminator, tileIndex, lamports) {
  const buf = new Uint8Array(10); // 1 + 1 + 8
  buf[0] = discriminator & 0xff;
  buf[1] = tileIndex & 0xff;
  writeU64LEInto(buf, 2, lamports);
  return buf;
}

function getConnection() {
  return new solanaWeb3.Connection(APP_CONFIG.RPC, 'confirmed');
}

/* ---------- Dynamic instruction account template ----------
   We fetch an example transaction you provided and extract the accounts used by the ORE program instruction.
   Then we replace the fee payer account in that template with the actual connected user wallet at runtime.
*/
let sampleAccountsTemplate = null;
let sampleFeePayerPubkeyStr = null;

async function deriveAccountsTemplateFromSampleTx() {
  try {
    const conn = getConnection();
    // Use getParsedTransaction to get human-readable instruction & account info
    const resp = await conn.getParsedTransaction(SAMPLE_TX_SIG, 'confirmed');
    if (!resp || !resp.transaction || !resp.transaction.message) {
      diagLog('Sample tx not found or unexpected format.');
      return null;
    }

    // accountKeys: array of { pubkey, signer, writable } (parsed)
    const accountKeysParsed = resp.transaction.message.accountKeys || [];
    // Determine fee payer (accountKeys[0] is usually fee payer)
    sampleFeePayerPubkeyStr = (accountKeysParsed[0] && (accountKeysParsed[0].pubkey || accountKeysParsed[0].toString())) || null;

    // Find the instruction for the ORE program
    const instructions = resp.transaction.message.instructions || [];
    let oreIx = null;
    for (const ix of instructions) {
      // instruction might have programId or programIdIndex; with parsed tx, programId should be present
      const progId = ix.programId ? ix.programId.toString() : (ix.program ? ix.program : null);
      if (progId && progId === ORE_PROGRAM.toString()) { oreIx = ix; break; }
    }
    if (!oreIx) {
      diagLog('No instruction with ORE_PROGRAM found in sample tx.');
      return null;
    }

    // oreIx.accounts is an array of account pubkey strings (for parsed transactions) or indices (for non-parsed)
    const accountMetas = [];
    for (const acctEntry of oreIx.accounts) {
      // acctEntry is likely a string pubkey
      const pubStr = (typeof acctEntry === 'string') ? acctEntry : (acctEntry.pubkey ? acctEntry.pubkey.toString() : acctEntry.toString());
      // find signer/writable flags in accountKeysParsed
      const keyMeta = accountKeysParsed.find(k => (k.pubkey && k.pubkey.toString ? k.pubkey.toString() : k.pubkey || k.toString()) === pubStr);
      const isSigner = keyMeta ? (keyMeta.signer || keyMeta.isSigner || false) : false;
      const isWritable = keyMeta ? (keyMeta.writable || keyMeta.isWritable || false) : false;
      accountMetas.push({
        pubkey: new solanaWeb3.PublicKey(pubStr),
        isSigner,
        isWritable
      });
    }

    sampleAccountsTemplate = accountMetas;
    diagLog(`Derived ${accountMetas.length} accounts from sample tx for ORE_PROGRAM.`);
    return accountMetas;
  } catch (e) {
    diagLog('deriveAccountsTemplateFromSampleTx error: ' + (e && e.message));
    return null;
  }
}

/* ---------- App ---------- */
function App() {
  const [wallet, setWallet] = useState(null);
  const [balance, setBalance] = useState(0);
  const [tiles, setTiles] = useState([]);
  const [perTile, setPerTile] = useState(0.0001);
  const [total, setTotal] = useState(0);
  const [streak, setStreak] = useState(0);
  const [running, setRunning] = useState(false);
  const [log, setLog] = useState(["Loading Privy..."]);
  const runningRef = useRef(false);

  const logMsg = m => {
    setLog(l => {
      const next = [...l.slice(-29), `${new Date().toLocaleTimeString()}: ${m}`];
      return next;
    });
  };

  useEffect(() => { runningRef.current = running; }, [running]);

  useEffect(() => {
    let attempts = 0;
    const init = () => {
      if (window.Privy) {
        try {
          const privy = new window.Privy({
            appId: APP_CONFIG.PRIVY_APP_ID,
            chainId: 101  // Solana mainnet
          });
          privy.on && privy.on('login', async user => {
            if (!user || !user.wallet || !user.wallet.address) {
              logMsg("Privy login returned unexpected shape.");
              return;
            }
            setWallet(user.wallet);
            logMsg("Connected: " + user.wallet.address.slice(0,8) + "...");
            try {
              const conn = getConnection();
              const bal = await conn.getBalance(new solanaWeb3.PublicKey(user.wallet.address));
              setBalance(bal / 1e9);
            } catch (e) {
              logMsg("Balance read failed: " + (e && e.message || e));
            }

            // Once wallet is connected, attempt to derive the account template from the sample tx
            try {
              const accounts = await deriveAccountsTemplateFromSampleTx();
              if (accounts && accounts.length) {
                logMsg("Derived instruction account template from sample transaction.");
              } else {
                logMsg("Could not derive instruction accounts from sample transaction — using fallback template.");
              }
            } catch (e) {
              logMsg("Error deriving sample accounts: " + (e && e.message));
            }
          });
          window.privy = privy;
          logMsg("Privy ready – click SIGN IN");
        } catch (e) {
          logMsg("Privy initialization error: " + (e && e.message));
        }
      } else if (attempts < 20) {
        attempts++;
        setTimeout(init, 500);
      } else {
        logMsg("Privy failed to load. Ensure auth.privy.io/core.umd.min.js is reachable.");
      }
    };
    init();
  }, []);

  const login = () => {
    if (window.privy && window.privy.login) window.privy.login();
    else { logMsg("Privy still loading..."); setTimeout(login, 1000); }
  };

  const toggle = i => runningRef.current ? null : setTiles(t => t.includes(i) ? t.filter(x => x !== i) : [...t, i].sort((a,b)=>a-b));

  const start = () => {
    if (!tiles.length) return alert("Select tiles!");
    setTotal(tiles.length * perTile);
    setRunning(true);
    runningRef.current = true;
    setStreak(0);
    logMsg(`STARTED – ${tiles.length} tiles @ ${perTile} SOL`);
    runCycle();
  };

  const stop = () => {
    setRunning(false);
    runningRef.current = false;
    logMsg("STOPPED by user");
  };

  /* Wallet send wrapper */
  async function walletSendTransaction(tx, connection) {
    if (!wallet) throw new Error("No wallet");
    if (wallet.signAndSendTransaction) {
      try {
        const res = await wallet.signAndSendTransaction({ transaction: tx, connection });
        if (res && res.signature) return res.signature;
      } catch (e) {
        logMsg("signAndSendTransaction failed, trying signTransaction fallback: " + (e && e.message));
      }
    }
    if (wallet.signTransaction) {
      const signed = await wallet.signTransaction(tx);
      const raw = signed.serialize();
      const sig = await connection.sendRawTransaction(raw);
      return sig;
    }
    if (wallet.request) {
      try {
        const raw = tx.serialize();
        const sig = await wallet.request({ method: 'sendTransaction', params: [raw] });
        if (sig) return sig;
      } catch (e) {}
    }
    throw new Error("Wallet provider missing supported transaction API");
  }

  /* Build instruction accounts for a bet. If we successfully derived a template from the sample tx,
     we reuse that template and substitute the sample fee payer with the connected userWallet.
     Otherwise we fall back to a minimal example (payer + mint).
  */
  function instructionAccountsForTile(userPubkey, tileIndex) {
    if (sampleAccountsTemplate && sampleAccountsTemplate.length) {
      return sampleAccountsTemplate.map(a => {
        // Replace sample fee payer with connected user's pubkey
        if (sampleFeePayerPubkeyStr && a.pubkey.toString() === sampleFeePayerPubkeyStr) {
          return { pubkey: userPubkey, isSigner: true, isWritable: a.isWritable };
        }
        // Leave other accounts intact
        return { pubkey: a.pubkey, isSigner: a.isSigner, isWritable: a.isWritable };
      });
    }
    // Fallback: minimal example (you should still verify these are what the ORE program requires)
    return [
      { pubkey: userPubkey, isSigner: true, isWritable: true },
      { pubkey: ORE_MINT, isSigner: false, isWritable: false }
    ];
  }

  async function sendBetForTile(tileIndex, lamportsPerTile) {
    const conn = getConnection();
    const payer = new solanaWeb3.PublicKey(wallet.address);
    const data = buildInstructionData(2, tileIndex, lamportsPerTile);
    const keys = instructionAccountsForTile(payer, tileIndex);

    const ix = new solanaWeb3.TransactionInstruction({
      programId: ORE_PROGRAM,
      keys,
      data
    });

    const tx = new solanaWeb3.Transaction().add(ix);
    const latest = await conn.getLatestBlockhash();
    tx.recentBlockhash = latest.blockhash;
    tx.feePayer = payer;

    const sig = await walletSendTransaction(tx, conn);
    try {
      await conn.confirmTransaction(sig, 'confirmed');
    } catch (e) {
      logMsg("Confirmation error: " + (e && e.message));
    }
    return sig;
  }

  async function runCycle() {
    if (!runningRef.current) return;
    if (!wallet) { logMsg("No wallet connected"); setRunning(false); return; }

    try {
      const lamports = Math.floor((total / tiles.length) * 1e9);
      for (const t of tiles) {
        if (!runningRef.current) break;
        try {
          const sig = await sendBetForTile(t, lamports);
          logMsg(`Bet ${(lamports/1e9).toFixed(6)} SOL on tile ${t+1} → ${sig.slice(0,8)}...`);
          await new Promise(r => setTimeout(r, 800));
        } catch (e) {
          logMsg(`Error sending tile ${t+1}: ${e && e.message || e}`);
        }
      }

      // wait for round resolution
      await new Promise(r => setTimeout(r, 65000));

      // fetch recent winning tile
      let winning = null;
      try {
        const res = await fetch("https://ore.supply/api/recent?limit=1");
        if (res.ok) {
          const d = await res.json();
          if (Array.isArray(d) && d.length > 0 && typeof d[0].winning_tile !== 'undefined') {
            winning = d[0].winning_tile;
          } else {
            logMsg("Unexpected ore.supply response shape");
          }
        } else {
          logMsg("ore.supply fetch failed: " + res.status);
        }
      } catch (e) {
        logMsg("ore.supply fetch error: " + (e && e.message));
      }

      if (winning !== null) {
        if (tiles.includes(winning)) {
          logMsg(`HIT ${winning+1}!!! Resetting bet to base`);
          setStreak(0);
          setTotal(tiles.length * perTile);
        } else {
          const next = total * 2;
          setStreak(s => s + 1);
          setTotal(next > balance * 0.8 ? tiles.length * perTile : next);
          logMsg(`Miss – next ${total.toFixed(6)} SOL`);
        }
      } else {
        logMsg("No winning tile info retrieved this round.");
      }

      try {
        const b = await getConnection().getBalance(new solanaWeb3.PublicKey(wallet.address));
        setBalance(b / 1e9);
      } catch (e) {
        logMsg("Balance update failed: " + (e && e.message));
      }

      if (runningRef.current) setTimeout(runCycle, 2000);
    } catch (e) {
      logMsg("runCycle error: " + (e && e.message));
      if (runningRef.current) setTimeout(runCycle, 10000);
    }
  }

  return React.createElement('div', null,
    !wallet ?
      React.createElement('button', {onClick: login, style:{fontSize:'28px',padding:'20px 60px'}}, "SIGN IN WITH PRIVY") :
      React.createElement(React.Fragment, null,
        React.createElement('p', null, `Balance: ${balance.toFixed(4)} SOL`),
        React.createElement('div', {id:'grid'}, Array.from({length:25},(_,i)=>React.createElement('div',{
          key:i,className:`tile ${tiles.includes(i)?'selected':''}`,onClick:()=>toggle(i)
        },i+1))),
        React.createElement('p', null, "Tiles: "+(tiles.length?tiles.map(t=>t+1).join(", "):"none")),
        React.createElement('input',{type:"number",step:"0.000001",value:perTile,
          onChange:e=>setPerTile(Math.max(parseFloat(e.target.value)||0.000001, 0.000001))}),
        React.createElement('br'),
        React.createElement('button',{onClick:start,disabled:running},"START BOT"),
        running&&React.createElement('button',{className:"stop",onClick:stop},"STOP"),
        React.createElement('p', null, `Bet: ${total.toFixed(6)} SOL | Streak: ${streak}`),
        React.createElement('div',{className:'log'},log.map((l,i)=>React.createElement('div',{key:i},l)))
      )
  );
}

/* Mount */
(function mount() {
  const rootEl = document.getElementById('root');
  if (ReactDOM && ReactDOM.createRoot) {
    ReactDOM.createRoot(rootEl).render(React.createElement(App));
  } else {
    ReactDOM.render(React.createElement(App), rootEl);
  }
})();
</script>
</body>
</html>
